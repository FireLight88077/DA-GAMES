<!DOCTYPE html>
<html>
<head>
  <title>Raycasting Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<img id="enemySprite" src="Obunga_in_Parking_Lot.webp" style="display:none;" />
<img id="enemySprite2" src="your_second_enemy_image.webp" style="display:none;" />
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const TILE_SIZE = 64;
const MAP_WIDTH = 51;
const MAP_HEIGHT = 51;
let map = generateMazeMap(MAP_WIDTH, MAP_HEIGHT);

function generateMazeMap(width, height) {
  const maze = Array.from({ length: height }, () => Array(width).fill(1));
  const visited = Array.from({ length: height }, () => Array(width).fill(false));

  function carve(x, y) {
    maze[y][x] = 0;
    visited[y][x] = true;
    const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random() - 0.5);
    for (const [dx, dy] of dirs) {
      const nx = x + dx, ny = y + dy;
      if (nx > 0 && ny > 0 && nx < width - 1 && ny < height - 1 && !visited[ny][nx]) {
        maze[y + dy / 2][x + dx / 2] = 0;
        carve(nx, ny);
      }
    }
  }

  carve(1, 1);
  return maze;
}

let posX = TILE_SIZE * 1.5, posY = TILE_SIZE * 1.5;
let dir = 0;
const FOV = Math.PI / 3;
let keys = {};
let health = 100;

let enemyX = TILE_SIZE * 5;
let enemyY = TILE_SIZE * 5;
let enemyStunned = false;
let stunTimer = 0;

let enemy2X = TILE_SIZE * 8;
let enemy2Y = TILE_SIZE * 8;
let enemy2Stunned = false;
let enemy2StunTimer = 0;

const enemyImg = document.getElementById("enemySprite");
const enemyImg2 = document.getElementById("enemySprite2");

let canShoot = true;
let lastHitTime = 0;
let laserTimer = 0;
let laserStart = null;
let laserEnd = null;

let gameStarted = false;

document.addEventListener("keydown", e => {
  keys[e.key] = true;
  if (!gameStarted && e.code === "Enter") {
    gameStarted = true;
    gameLoop();
  }
  if (gameStarted && e.code === "Space" && canShoot) {
    shoot();
    canShoot = false;
    setTimeout(() => canShoot = true, 500);
  }
});
document.addEventListener("keyup", e => keys[e.key] = false);

function updatePlayer() {
  const moveSpeed = 1;
  const turnSpeed = 0.03;

  if (keys["ArrowLeft"]) dir -= turnSpeed;
  if (keys["ArrowRight"]) dir += turnSpeed;

  let nextX = posX;
  let nextY = posY;

  if (keys["ArrowUp"]) {
    nextX += Math.cos(dir) * moveSpeed;
    nextY += Math.sin(dir) * moveSpeed;
  }
  if (keys["ArrowDown"]) {
    nextX -= Math.cos(dir) * moveSpeed;
    nextY -= Math.sin(dir) * moveSpeed;
  }

  const gridX = Math.floor(nextX / TILE_SIZE);
  const gridY = Math.floor(nextY / TILE_SIZE);
  if (map[gridY]?.[gridX] === 0) {
    posX = nextX;
    posY = nextY;
  }
}

function updateEnemy(x, y, stunned, stunTimer, damage) {
  const speed = 1.5;
  const dx = posX - x;
  const dy = posY - y;
  const dist = Math.hypot(dx, dy);
  const dirX = dx / dist;
  const dirY = dy / dist;

  let nextX = x + dirX * speed;
  let nextY = y + dirY * speed;

  const tileX = Math.floor(nextX / TILE_SIZE);
  const tileY = Math.floor(y / TILE_SIZE);
  const tileY2 = Math.floor(nextY / TILE_SIZE);
  const tileX2 = Math.floor(x / TILE_SIZE);

  if (map[tileY]?.[tileX] === 0) x = nextX;
  if (map[tileY2]?.[tileX2] === 0) y = nextY;

  const distToPlayer = Math.hypot(x - posX, y - posY);
  if (!stunned && distToPlayer < 40 && Date.now() - lastHitTime > 1000) {
    health -= damage;
    lastHitTime = Date.now();
  }

  if (stunned) {
    stunTimer--;
    if (stunTimer <= 0) stunned = false;
  }

  return [x, y, stunned, stunTimer];
}

function updateEnemies() {
  [enemyX, enemyY, enemyStunned, stunTimer] = updateEnemy(enemyX, enemyY, enemyStunned, stunTimer, 10);
  [enemy2X, enemy2Y, enemy2Stunned, enemy2StunTimer] = updateEnemy(enemy2X, enemy2Y, enemy2Stunned, enemy2StunTimer, 40);
}

function shoot() {
  laserTimer = 10;
  laserStart = { x: posX, y: posY };
  laserEnd = {
    x: posX + Math.cos(dir) * 300,
    y: posY + Math.sin(dir) * 300
  };

  [
    [enemyX, enemyY, val => enemyStunned = val, val => stunTimer = val],
    [enemy2X, enemy2Y, val => enemy2Stunned = val, val => enemy2StunTimer = val]
  ].forEach(([ex, ey, setStun, setTimer]) => {
    const dx = ex - posX;
    const dy = ey - posY;
    const angleToEnemy = Math.atan2(dy, dx);
    const angleDiff = Math.abs(angleToEnemy - dir);
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (angleDiff < 0.3 && dist < 300) {
      let blocked = false;
      for (let d = 0; d < dist; d += 4) {
        const testX = Math.floor((posX + Math.cos(angleToEnemy) * d) / TILE_SIZE);
        const testY = Math.floor((posY + Math.sin(angleToEnemy) * d) / TILE_SIZE);
        if (map[testY]?.[testX] === 1) {
          blocked = true;
          break;
        }
      }
      if (!blocked) {
        setStun(true);
        setTimer(180);
      }
    }
  });
}

function castRays() {
  const numRays = canvas.width;
  const angleStep = FOV / numRays;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let x = 0; x < numRays; x++) {
    const rayAngle = dir - FOV / 2 + x * angleStep;
    let distance = 0;
    let hit = false;

    while (!hit && distance < 1000) {
      distance += 1;
      const testX = Math.floor((posX + Math.cos(rayAngle) * distance) / TILE_SIZE);
      const testY = Math.floor((posY + Math.sin(rayAngle) * distance) / TILE_SIZE);
      if (testX < 0 || testX >= MAP_WIDTH || testY < 0 || testY >= MAP_HEIGHT) {
        hit = true;
        distance = 1000;
      } else if (map[testY][testX] > 0) {
        hit = true;
      }
    }

    const correctedDistance = distance * Math.cos(rayAngle - dir);
    const wallHeight = Math.min(30000 / correctedDistance, canvas.height);
    const shade = 255 - Math.min(255, correctedDistance / 2);
    ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
    ctx.fillRect(x, canvas.height / 2 - wallHeight / 2, 1, wallHeight);
  }
}

function drawEnemyIn3D(x, y, img) {
  const dx = x - posX;
  const dy = y - posY;
  const angleToEnemy = Math.atan2(dy, dx);
  let angleDiff = angleToEnemy - dir;

  while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
  while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

  if (Math.abs(angleDiff) < FOV / 2) {
    const distToEnemy = Math.sqrt(dx * dx + dy * dy);
    let blocked = false;
    for (let d = 0; d < distToEnemy; d += 4) {
      const testX = Math.floor((posX + Math.cos(angleToEnemy) * d) / TILE_SIZE);
      const testY = Math.floor((posY + Math.sin(angleToEnemy) * d) / TILE_SIZE);
      if (map[testY]?.[testX] === 1) {
        blocked = true;
        break;
      }
    }

    if (!blocked) {
      const correctedDist = distToEnemy * Math.cos(angleDiff);
      const enemyHeight = Math.min(30000 / correctedDist, canvas.height);
      const screenX = Math.floor((angleDiff + FOV / 2) / FOV * canvas.width);

      const spriteSize = enemyHeight;
      const spriteY = canvas.height / 2 - spriteSize / 2;

      ctx.drawImage(img, screenX - spriteSize / 2, spriteY, spriteSize, spriteSize);
    }
  }
}

function drawLaser() {
  if (laserTimer > 0 && laserStart && laserEnd) {
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(
      (laserStart.x / (MAP_WIDTH * TILE_SIZE)) * canvas.width,
      (laserStart.y / (MAP_HEIGHT * TILE_SIZE)) * canvas.height
    );
    ctx.lineTo(
      (laserEnd.x / (MAP_WIDTH * TILE_SIZE)) * canvas.width,
      (laserEnd.y / (MAP_HEIGHT * TILE_SIZE)) * canvas.height
    );
    ctx.stroke();
    laserTimer--;
  }
}

function drawHealthBar() {
  const barWidth = 200;
  const barHeight = 20;
  const x = 20;
  const y = 20;

  ctx.fillStyle = "#444";
  ctx.fillRect(x, y, barWidth, barHeight);

  ctx.fillStyle = health > 30 ? "lime" : "red";
  ctx.fillRect(x, y, (health / 100) * barWidth, barHeight);

  ctx.strokeStyle = "#fff";
  ctx.strokeRect(x, y, barWidth, barHeight);
}

function drawMinimap() {
  const scale = 4;
  const mmWidth = MAP_WIDTH * scale;
  const mmHeight = MAP_HEIGHT * scale;
  const offsetX = canvas.width - mmWidth - 20;
  const offsetY = 20;

  for (let y = 0; y < MAP_HEIGHT; y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
      ctx.fillStyle = map[y][x] === 1 ? "#888" : "#222";
      ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale, scale);
    }
  }

  const px = offsetX + (posX / TILE_SIZE) * scale;
  const py = offsetY + (posY / TILE_SIZE) * scale;
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(px, py, 3, 0, Math.PI * 2);
  ctx.fill();

  const dx = Math.cos(dir) * 10;
  const dy = Math.sin(dir) * 10;
  ctx.strokeStyle = "lime";
  ctx.beginPath();
  ctx.moveTo(px, py);
  ctx.lineTo(px + dx, py + dy);
  ctx.stroke();

  const ex1 = offsetX + (enemyX / TILE_SIZE) * scale;
  const ey1 = offsetY + (enemyY / TILE_SIZE) * scale;
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(ex1, ey1, 3, 0, Math.PI * 2);
  ctx.fill();

  const ex2 = offsetX + (enemy2X / TILE_SIZE) * scale;
  const ey2 = offsetY + (enemy2Y / TILE_SIZE) * scale;
  ctx.fillStyle = "orange";
  ctx.beginPath();
  ctx.arc(ex2, ey2, 3, 0, Math.PI * 2);
  ctx.fill();
}

function drawMainMenu() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.font = "bold 48px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Raycasting Maze Game", canvas.width / 2, canvas.height / 2 - 60);
  ctx.font = "24px sans-serif";
  ctx.fillText("Press ENTER to start", canvas.width / 2, canvas.height / 2);
  ctx.fillText("Arrow keys to move, SPACE to shoot", canvas.width / 2, canvas.height / 2 + 40);
}

function gameLoop() {
  if (!gameStarted) {
    drawMainMenu();
    requestAnimationFrame(gameLoop);
    return;
  }

  updatePlayer();
  updateEnemies();
  castRays();
  drawEnemyIn3D(enemyX, enemyY, enemyImg);
  drawEnemyIn3D(enemy2X, enemy2Y, enemyImg2);
  drawLaser();
  drawHealthBar();
  drawMinimap();

  if (health <= 0) {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "red";
    ctx.font = "bold 48px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("You Died", canvas.width / 2, canvas.height / 2);
    return;
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
